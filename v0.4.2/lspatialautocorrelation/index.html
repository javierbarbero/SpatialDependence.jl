<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Local Spatial Autocorrelation · SpatialDependence.jl</title><meta name="title" content="Local Spatial Autocorrelation · SpatialDependence.jl"/><meta property="og:title" content="Local Spatial Autocorrelation · SpatialDependence.jl"/><meta property="twitter:title" content="Local Spatial Autocorrelation · SpatialDependence.jl"/><meta name="description" content="Documentation for SpatialDependence.jl."/><meta property="og:description" content="Documentation for SpatialDependence.jl."/><meta property="twitter:description" content="Documentation for SpatialDependence.jl."/><meta property="og:url" content="https://javierbarbero.github.io/SpatialDependence.jl/lspatialautocorrelation/"/><meta property="twitter:url" content="https://javierbarbero.github.io/SpatialDependence.jl/lspatialautocorrelation/"/><link rel="canonical" href="https://javierbarbero.github.io/SpatialDependence.jl/lspatialautocorrelation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpatialDependence.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../sweightmatrices/">Spatial Weight Matrices</a></li><li><a class="tocitem" href="../spatiallag/">Spatial Lag</a></li><li><a class="tocitem" href="../gspatialautocorrelation/">Global Spatial Autocorrelation</a></li><li class="is-active"><a class="tocitem" href>Local Spatial Autocorrelation</a><ul class="internal"><li><a class="tocitem" href="#Local-Moran"><span>Local Moran</span></a></li><li><a class="tocitem" href="#Local-Geary"><span>Local Geary</span></a></li><li><a class="tocitem" href="#Getis-Ord-Statistics"><span>Getis-Ord Statistics</span></a></li><li><a class="tocitem" href="#Significance"><span>Significance</span></a></li><li><a class="tocitem" href="#LISA-Cluster-Map"><span>LISA Cluster Map</span></a></li></ul></li><li><a class="tocitem" href="../choropleth/">Choropleth Maps</a></li><li><a class="tocitem" href="../parallelcomputing/">Parallel Computing</a></li><li><a class="tocitem" href="../bibliography/">Bibliography</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Local Spatial Autocorrelation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Local Spatial Autocorrelation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/javierbarbero/SpatialDependence.jl/blob/main/docs/src/lspatialautocorrelation.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Local-Spatial-Autocorrelation"><a class="docs-heading-anchor" href="#Local-Spatial-Autocorrelation">Local Spatial Autocorrelation</a><a id="Local-Spatial-Autocorrelation-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Spatial-Autocorrelation" title="Permalink"></a></h1><p>Local spatial autocorrelation statistics are used to discover clusters (hot spots or cold spots) and spatial outliers. Local Indicators of Spatial Association (LISA), introduced by Anselin (1995), are local spatial statistics that provide a statistic for each location and assess its contribution to the corresponding global spatial autocorrelation statistic.</p><p>Inference is performed through a computational conditional permutation approach by randomly reshuffling the values of the variable to different locations while the value of the observation under consideration is held fixed at its location. The observed statistic for each location is compared to a reference distribution under the null hypothesis of spatial randomness.</p><p>All the examples on this page assume that the Guerry dataset is loaded and a polygon contiguity spatial weights object has been built and row-standardized.</p><pre><code class="language-julia hljs">using SpatialDatasets
using SpatialDependence
using StableRNGs
using Plots

guerry = sdataset(&quot;Guerry&quot;)
W = polyneigh(guerry)</code></pre><h2 id="Local-Moran"><a class="docs-heading-anchor" href="#Local-Moran">Local Moran</a><a id="Local-Moran-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Moran" title="Permalink"></a></h2><p>Local Moran (Anselin, 1995) is the most used local spatial autocorrelation statistic. It is computed as:</p><p class="math-container">\[I_i = \frac{z_i}{m_2} \sum_{j}w_{ij}z_{j}\]</p><p>where <span>$z$</span> is the variable of interest in deviations from the mean, and <span>$m_2 = \sum_{i}z_i^{2} / (n - 1)$</span> or  <span>$m_2 = \sum_{i}z_i^{2} / n$</span> is the scaling factor.</p><p>Local Moran can be computed with the <code>localmoran</code> function. By default, <span>$9,999$</span> permutations are calculated for the inference. It is possible to specify a different number of permutations with the <code>permutations</code> optional parameter. For reproducibility, it is possible to specify a custom random number generator with the <code>rng</code> optional parameter. If <code>corrected</code> is set to <code>false</code> the scaling factor is divided by <span>$n$</span> instead of <span>$n - 1$</span>.</p><pre><code class="language-julia hljs">lmguerry = localmoran(guerry.Litercy, W, permutations = 9999, rng = StableRNG(1234567))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Local Moran test of Spatial Autocorrelation
--------------------------------------------

Randomization test with 9999 permutations.
Interesting locations at 0.05 significance level:
       High-High: 18
         Low-Low: 20
        Low-High: 0
        High-Low: 0
</code></pre><p>In the Local Moran, observations are classified in four categories, depending on the value of the attribute and the value of their neighbors with respect to the mean:</p><table><tr><th style="text-align: left">Code</th><th style="text-align: left">Category</th><th style="text-align: left">Cluster or Outliers</th><th style="text-align: left">Interpretation</th></tr><tr><td style="text-align: left"><code>:HH</code></td><td style="text-align: left">High-High</td><td style="text-align: left">Cluster: hot spot</td><td style="text-align: left">High values surrounded by high values</td></tr><tr><td style="text-align: left"><code>:LL</code></td><td style="text-align: left">Low-Low</td><td style="text-align: left">Cluster: cold spot</td><td style="text-align: left">Low values surrounded by low values</td></tr><tr><td style="text-align: left"><code>:LH</code></td><td style="text-align: left">Low-High</td><td style="text-align: left">Outlier: doughnut</td><td style="text-align: left">Low values surrounded by high values</td></tr><tr><td style="text-align: left"><code>:HL</code></td><td style="text-align: left">High-Low</td><td style="text-align: left">Outlier: diamond</td><td style="text-align: left">High values surrounded by low values</td></tr></table><p>The category to which each observation is assigned can be retrieved with the <code>assignments</code> function:</p><pre><code class="language-julia hljs">assignments(lmguerry)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Symbol}:
 :LH
 :HH
 :LL
 :HH
 :HL
 :LL
 :HH
 :LL
 :HH
 :LL
 ⋮
 :LL
 :LL
 :LH
 :LL
 :LL
 :LL
 :LL
 :HH
 :HH</code></pre><h2 id="Local-Geary"><a class="docs-heading-anchor" href="#Local-Geary">Local Geary</a><a id="Local-Geary-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Geary" title="Permalink"></a></h2><p>Local Geary (Anselin, 1995) is computed as:</p><p class="math-container">\[c_i = \frac{1}{m_2} \sum_{j}w_{ij}(z_{i} - z_{j})^2\]</p><p>where <span>$z$</span> is the variable of interest in deviations from the mean, and <span>$m_2 = \sum_{i}z_i^{2} / (n - 1)$</span> or  <span>$m_2 = \sum_{i}z_i^{2} / n$</span> is the scaling factor.</p><p>Local Geary can be computed with the <code>localgeary</code> function. By default, <span>$9,999$</span> permutations are calculated for the inference. It is possible to specify a different number of permutations with the <code>permutations</code> optional parameter. For reproducibility, it is possible to specify a custom random number generator with the <code>rng</code> optional parameter. If <code>corrected</code> is set to <code>false</code> the scaling factor is divided by <span>$n$</span> instead of <span>$n - 1$</span>.</p><pre><code class="language-julia hljs">lcguerry = localgeary(guerry.Litercy, W, permutations = 9999, rng = StableRNG(1234567))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Local Geary test of Spatial Autocorrelation
--------------------------------------------

Randomization test with 9999 permutations.
Interesting locations at 0.05 significance level:
        Positive: 49
        Negative: 0
</code></pre><p>In the Local Geary, observations are classified in two categories:</p><table><tr><th style="text-align: left">Code</th><th style="text-align: left">Category</th><th style="text-align: left">Interpretation</th></tr><tr><td style="text-align: left"><code>:P</code></td><td style="text-align: left">Positive</td><td style="text-align: left">Positive spatial autocorrelation</td></tr><tr><td style="text-align: left"><code>:N</code></td><td style="text-align: left">Negative</td><td style="text-align: left">Negative spatial autocorrelation</td></tr></table><p>The category to which each observation is assigned can be retrieved with the <code>assignments</code> function:</p><pre><code class="language-julia hljs">assignments(lcguerry)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Symbol}:
 :N
 :P
 :P
 :P
 :P
 :P
 :P
 :P
 :P
 :P
 ⋮
 :P
 :P
 :P
 :P
 :P
 :P
 :P
 :P
 :P</code></pre><p>Alternatively, observations can be interpreted together with the quadrants of the moran scatterplot if the parameter <code>categories</code> is set to <code>:moran</code>:</p><table><tr><th style="text-align: left">Code</th><th style="text-align: left">Category</th><th style="text-align: left">Interpretation</th></tr><tr><td style="text-align: left"><code>:HH</code></td><td style="text-align: left">High-High</td><td style="text-align: left">High values surrounded by high values</td></tr><tr><td style="text-align: left"><code>:LL</code></td><td style="text-align: left">Low-Low</td><td style="text-align: left">Low values surrounded by low values</td></tr><tr><td style="text-align: left"><code>:OP</code></td><td style="text-align: left">Other Positive</td><td style="text-align: left">Other positive spatial autocorrelation</td></tr><tr><td style="text-align: left"><code>:NE</code></td><td style="text-align: left">Negative</td><td style="text-align: left">Negative spatial autocorrelation</td></tr></table><h2 id="Getis-Ord-Statistics"><a class="docs-heading-anchor" href="#Getis-Ord-Statistics">Getis-Ord Statistics</a><a id="Getis-Ord-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Getis-Ord-Statistics" title="Permalink"></a></h2><p>There are two versions of the Getis-Ord statistics (Getis and Ord, 1992; Ord and Getis, 1995) computed as:</p><p class="math-container">\[G_i = \frac{\sum_{j} w_{ij}x_{j}}{\sum_{j} x_{j}} \qquad \forall j \ne i\]</p><p class="math-container">\[G_i^* = \frac{\sum_{j} w_{ij}x_{j}}{\sum_{j} x_{j}} \qquad \forall j\]</p><p>where <span>$x$</span> is the variable of interest. The <span>$G_i$</span> statistic excludes the value at the location <span>$x_i$</span> in the numerator and denominator, whereas the <span>$G_i^*$</span> statistic includes it. If the contiguity matrix is binary, the self weight is set to <span>$1$</span>, <span>$w_{ii} = 1$</span>, whereas if it is row-standardized, it is set to <span>$1$</span> divided by the number of neighbors of <span>$i$</span>, including the self.</p><p>Getis-Ord Statistics can be computed with the <code>getisord</code> function. The <span>$G_i^*$</span> statistic is computed if <code>star</code> is set to <code>true</code>, the default, whereas the <span>$G_i$</span> statistic is calculated if <code>star</code> is <code>false</code>. By default, <span>$9,999$</span> permutations are calculated for the inference. It is possible to specify a different number of permutations with the <code>permutations</code> optional parameter. For reproducibility, it is possible to specify a custom random number generator with the <code>rng</code> optional parameter.</p><pre><code class="language-julia hljs">gosguerry = getisord(guerry.Litercy, W, permutations = 9999, rng = StableRNG(1234567))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Getis-Ord Gi* test of Spatial Autocorrelation
--------------------------------------------

Randomization test with 9999 permutations.
Interesting locations at 0.05 significance level:
            High: 18
             Low: 20
</code></pre><pre><code class="language-julia hljs">goguerry = getisord(guerry.Litercy, W, permutations = 9999, rng = StableRNG(1234567), star = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Getis-Ord Gi test of Spatial Autocorrelation
--------------------------------------------

Randomization test with 9999 permutations.
Interesting locations at 0.05 significance level:
            High: 18
             Low: 20
</code></pre><p>In the Getis-Ord Statistics, observations are classified in two categories:</p><table><tr><th style="text-align: left">Code</th><th style="text-align: left">Category</th><th style="text-align: left">Interpretation</th></tr><tr><td style="text-align: left"><code>:H</code></td><td style="text-align: left">High</td><td style="text-align: left">Cluster of high values</td></tr><tr><td style="text-align: left"><code>:L</code></td><td style="text-align: left">Low</td><td style="text-align: left">Cluster of low values</td></tr></table><p>The category to which each observation is assigned can be retrieved with the <code>assignments</code> function:</p><pre><code class="language-julia hljs">assignments(goguerry)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Symbol}:
 :H
 :H
 :L
 :H
 :H
 :L
 :H
 :L
 :H
 :L
 ⋮
 :L
 :L
 :H
 :L
 :L
 :L
 :L
 :H
 :H</code></pre><h2 id="Significance"><a class="docs-heading-anchor" href="#Significance">Significance</a><a id="Significance-1"></a><a class="docs-heading-anchor-permalink" href="#Significance" title="Permalink"></a></h2><p>The conditional randomization procedure returns a pseudo p-value that can be used to assed the significance of the identified clusters and spatial outliers. The function <code>issignificant</code> returns a vector of boolean values indicating if the local statistics are significant at the desired threshold level:</p><pre><code class="language-julia hljs">issignificant(lmguerry, 0.05)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Bool}:
 0
 1
 1
 0
 0
 0
 1
 0
 1
 0
 ⋮
 0
 0
 0
 0
 0
 1
 1
 1
 0</code></pre><p>As multiple tests are performed on the same dataset, the p-values suffer from the problem of multiple comparisons, leading to many false positives (exceeding the nominal Type I error rate). Multiple solutions have been suggested in the literature to address this issue. Some of them are implemented through the <code>adjust</code> parameter. Set the parameter to <code>:bonferroni</code> for the conservative Bonferroni approach. For the <em>False Discovery Rate</em>, set the parameter to <code>:fdr</code>. </p><pre><code class="language-julia hljs">issignificant(lmguerry, 0.05, adjust = :fdr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Bool}:
 0
 0
 1
 0
 0
 0
 1
 0
 1
 0
 ⋮
 0
 0
 0
 0
 0
 0
 1
 1
 0</code></pre><p>For convenience, it is possible to get the category to which each observation is assigned while identifying which ones are not significant. This is done by specifiying a specifying threshold level and an adjustment method in the <code>assignments</code> function. Nonsignificant observations are labeled as <code>:ns</code>.</p><pre><code class="language-julia hljs">assignments(lmguerry, 0.05, adjust = :none)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">85-element Vector{Symbol}:
 :ns
 :HH
 :LL
 :ns
 :ns
 :ns
 :HH
 :ns
 :HH
 :ns
 ⋮
 :ns
 :ns
 :ns
 :ns
 :ns
 :LL
 :LL
 :HH
 :ns</code></pre><h2 id="LISA-Cluster-Map"><a class="docs-heading-anchor" href="#LISA-Cluster-Map">LISA Cluster Map</a><a id="LISA-Cluster-Map-1"></a><a class="docs-heading-anchor-permalink" href="#LISA-Cluster-Map" title="Permalink"></a></h2><p>A cluster map with the significant locations can be plotted with the <code>plot</code> function if the <a href="http://docs.juliaplots.org">Plots.jl</a> package is loaded:</p><pre><code class="language-julia hljs">plot(guerry, lmguerry)</code></pre><img src="5416da60.svg" alt="Example block output"/><p>The threshold significance value and the adjustment can also be set when plotting a cluster map with the <code>sig</code> and <code>adjust</code> parameters:</p><pre><code class="language-julia hljs">plot(guerry, lmguerry, sig = 0.05, adjust = :fdr)</code></pre><img src="036db4ca.svg" alt="Example block output"/><p>If not specified, the default threshold significance  value is <code>0.05</code> and the <code>adjust</code> parameter is <code>:none</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gspatialautocorrelation/">« Global Spatial Autocorrelation</a><a class="docs-footer-nextpage" href="../choropleth/">Choropleth Maps »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Saturday 20 April 2024 14:17">Saturday 20 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
